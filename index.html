<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hand Gesture Recognition System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>

    <!-- Replace your current MediaPipe scripts with these: -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.4.1646424915/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.4.1646424915/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
      }

      .container {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        max-width: 900px;
        width: 100%;
      }

      h1 {
        text-align: center;
        color: white;
        font-size: 2.5em;
        margin-bottom: 30px;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      .video-container {
        position: relative;
        display: flex;
        justify-content: center;
        margin-bottom: 30px;
      }

      #videoElement {
        width: 640px;
        height: 480px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        background: #000;
      }

      .canvas-overlay {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
        border-radius: 15px;
      }

      .controls {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin-bottom: 30px;
        flex-wrap: wrap;
      }

      button {
        padding: 12px 24px;
        font-size: 16px;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .btn-primary {
        background: linear-gradient(45deg, #4caf50, #45a049);
        color: white;
        box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(76, 175, 80, 0.6);
      }

      .btn-secondary {
        background: linear-gradient(45deg, #2196f3, #1976d2);
        color: white;
        box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
      }

      .btn-secondary:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(33, 150, 243, 0.6);
      }

      .btn-warning {
        background: linear-gradient(45deg, #ff9800, #f57c00);
        color: white;
        box-shadow: 0 5px 15px rgba(255, 152, 0, 0.4);
      }

      .btn-warning:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(255, 152, 0, 0.6);
      }

      .output-section {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 15px;
        padding: 25px;
        margin-bottom: 20px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
      }

      .output-section h3 {
        color: #333;
        margin-bottom: 15px;
        font-size: 1.4em;
      }

      #gestureOutput {
        font-size: 1.2em;
        font-weight: bold;
        color: #2196f3;
        margin-bottom: 10px;
        min-height: 30px;
        padding: 10px;
        background: rgba(33, 150, 243, 0.1);
        border-radius: 8px;
        border-left: 4px solid #2196f3;
      }

      #translatedText {
        font-size: 1.1em;
        color: #333;
        min-height: 100px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
        border: 1px solid #e9ecef;
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .debug-section {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 15px;
        padding: 25px;
        margin-bottom: 20px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
      }

      .debug-info {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 15px;
      }

      .debug-item {
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        border-left: 4px solid #28a745;
      }

      .debug-item label {
        font-weight: bold;
        color: #333;
        display: block;
        margin-bottom: 5px;
      }

      .debug-item span {
        color: #666;
        font-family: monospace;
      }

      .status-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
      }

      .status-active {
        background: #28a745;
        box-shadow: 0 0 5px rgba(40, 167, 69, 0.5);
      }

      .status-inactive {
        background: #dc3545;
      }

      .gesture-list {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 15px;
        padding: 25px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
      }

      .gesture-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 10px;
      }

      .gesture-item {
        background: #e3f2fd;
        padding: 10px;
        border-radius: 8px;
        text-align: center;
        border: 1px solid #bbdefb;
      }

      .gesture-item.detected {
        background: #c8e6c9;
        border-color: #4caf50;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      .error-message {
        background: #ffebee;
        color: #c62828;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        border-left: 4px solid #f44336;
        display: none;
      }

      @media (max-width: 768px) {
        .container {
          padding: 20px;
        }

        #videoElement {
          width: 100%;
          max-width: 480px;
          height: auto;
        }

        .controls {
          flex-direction: column;
          align-items: center;
        }

        button {
          width: 200px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ü§ö Hand Gesture Recognition System</h1>

      <div class="error-message" id="errorMessage"></div>

      <div class="video-container">
        <video id="videoElement" autoplay muted playsinline></video>
        <canvas id="canvasOverlay" class="canvas-overlay"></canvas>
      </div>

      <div class="controls">
        <button id="startBtn" class="btn-primary">Start Camera</button>
        <button id="stopBtn" class="btn-secondary" disabled>Stop Camera</button>
        <button id="clearBtn" class="btn-warning">Clear Text</button>
        <button id="trainBtn" class="btn-secondary">Train Gesture</button>
      </div>

      <div class="output-section">
        <h3>üéØ Current Gesture Detection</h3>
        <div id="gestureOutput">No gesture detected</div>
      </div>

      <div class="output-section">
        <h3>üìù Translated Text</h3>
        <div id="translatedText">Your translated text will appear here...</div>
      </div>

      <div class="debug-section">
        <h3>üîß Debug Information</h3>
        <div class="debug-info">
          <div class="debug-item">
            <label>Camera Status:</label>
            <span id="cameraStatus">
              <span class="status-indicator status-inactive"></span>Inactive
            </span>
          </div>
          <div class="debug-item">
            <label>Hands Detected:</label>
            <span id="handsDetected">0</span>
          </div>
          <div class="debug-item">
            <label>Confidence:</label>
            <span id="confidence">0%</span>
          </div>
          <div class="debug-item">
            <label>Frame Rate:</label>
            <span id="frameRate">0 FPS</span>
          </div>
          <div class="debug-item">
            <label>Processing Time:</label>
            <span id="processingTime">0ms</span>
          </div>
          <div class="debug-item">
            <label>Model Status:</label>
            <span id="modelStatus">Loading...</span>
          </div>
        </div>
      </div>

      <div class="gesture-list">
        <h3>üé≠ Available Gestures</h3>
        <div class="gesture-grid" id="gestureGrid">
          <div class="gesture-item" data-gesture="thumbs_up">üëç Thumbs Up</div>
          <div class="gesture-item" data-gesture="peace">‚úåÔ∏è Peace</div>
          <div class="gesture-item" data-gesture="fist">‚úä Fist</div>
          <div class="gesture-item" data-gesture="open_palm">üñêÔ∏è Open Palm</div>
          <div class="gesture-item" data-gesture="pointing">üëâ Pointing</div>
          <div class="gesture-item" data-gesture="ok_sign">üëå OK Sign</div>
        </div>
      </div>
    </div>

    <script>
      class HandGestureRecognizer {
        constructor() {
          this.video = document.getElementById("videoElement");
          this.canvas = document.getElementById("canvasOverlay");
          this.ctx = this.canvas.getContext("2d");
          this.isRunning = false;
          this.stream = null;
          this.animationId = null;

          // Performance tracking
          this.frameCount = 0;
          this.lastFrameTime = performance.now();
          this.processingTimes = [];

          // Gesture recognition
          this.currentGesture = null;
          this.gestureConfidence = 0;
          this.gestureHistory = [];
          this.translatedText = "";
          this.lastAddedGesture = null;
          this.gestureStabilityCounter = 0;
          this.minStabilityFrames = 10;

          // Hand landmarks
          this.handLandmarks = null;
          this.handsDetected = 0;

          // MediaPipe Hands
          this.hands = null;
          this.camera = null;
          this.useFallback = false;

          // Initialize MediaPipe hand detection
          this.initializeHandDetection();

          // Bind event listeners
          this.bindEvents();

          // Initialize UI
          this.updateUI();
        }

        async initializeHandDetection() {
          try {
            // Check if MediaPipe is available
            if (typeof Hands === "undefined") {
              console.warn(
                "MediaPipe Hands not loaded. Switching to fallback mode."
              );
              this.initializeFallbackDetection();
              return;
            }

            // Initialize MediaPipe Hands with correct CDN path
            this.hands = new Hands({
              locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
              },
            });

            this.hands.setOptions({
              maxNumHands: 2,
              modelComplexity: 1,
              minDetectionConfidence: 0.7,
              minTrackingConfidence: 0.5,
            });

            this.hands.onResults(this.onResults.bind(this));

            // Define gesture patterns with more accurate finger detection
            this.gesturePatterns = {
              thumbs_up: {
                name: "Thumbs Up",
                text: "Good ",
                check: this.isThumbsUp.bind(this),
              },
              thumbs_down: {
                name: "Thumbs Down",
                text: "Bad ",
                check: this.isThumbsDown.bind(this),
              },
              peace: {
                name: "Peace Sign",
                text: "Peace ",
                check: this.isPeaceSign.bind(this),
              },
              fist: {
                name: "Fist",
                text: "Stop ",
                check: this.isFist.bind(this),
              },
              open_palm: {
                name: "Open Palm",
                text: "Hello ",
                check: this.isOpenPalm.bind(this),
              },
              pointing: {
                name: "Pointing",
                text: "Look ",
                check: this.isPointing.bind(this),
              },
              ok_sign: {
                name: "OK Sign",
                text: "OK ",
                check: this.isOKSign.bind(this),
              },
              i_love_you: {
                name: "I Love You",
                text: "I love you ",
                check: this.isILoveYou.bind(this),
              },
              rock: {
                name: "Rock",
                text: "Rock On ",
                check: this.isRockSign.bind(this),
              },
              three: {
                name: "Three",
                text: "Three ",
                check: this.isNumberThree.bind(this),
              },
            };

            this.updateModelStatus("Ready");
            console.log("MediaPipe hand detection initialized successfully");
          } catch (error) {
            console.error("Error initializing MediaPipe:", error);
            this.updateModelStatus("Error");
            this.initializeFallbackDetection();
          }
        }

        initializeFallbackDetection() {
          console.log("Initializing fallback hand detection...");

          // Simple fallback without MediaPipe
          this.hands = null;
          this.camera = null;
          this.useFallback = true;

          // Define gesture patterns for fallback
          this.gesturePatterns = {
            thumbs_up: {
              name: "Thumbs Up",
              text: "Good ",
              check: () => 0.8,
            },
            thumbs_down: {
              name: "Thumbs Down",
              text: "Bad ",
              check: () => 0.8,
            },
            peace: {
              name: "Peace Sign",
              text: "Peace ",
              check: () => 0.8,
            },
            fist: {
              name: "Fist",
              text: "Stop ",
              check: () => 0.8,
            },
            open_palm: {
              name: "Open Palm",
              text: "Hello ",
              check: () => 0.8,
            },
            pointing: {
              name: "Pointing",
              text: "Look ",
              check: () => 0.8,
            },
            ok_sign: {
              name: "OK Sign",
              text: "OK ",
              check: () => 0.8,
            },
            rock: {
                name: "Rock",
                text: "Rock On ",
                check: () => 0.8,
              },
              three: {
                name: "Three",
                text: "Three ",
                check: () => 0.8,
              },
          };

          this.updateModelStatus("Fallback Mode");
          console.log("Fallback detection mode activated");
        }

        bindEvents() {
          document
            .getElementById("startBtn")
            .addEventListener("click", () => this.startCamera());
          document
            .getElementById("stopBtn")
            .addEventListener("click", () => this.stopCamera());
          document
            .getElementById("clearBtn")
            .addEventListener("click", () => this.clearText());
          document
            .getElementById("trainBtn")
            .addEventListener("click", () => this.trainGesture());

          // Handle window resize
          window.addEventListener("resize", () => this.resizeCanvas());
        }

        async startCamera() {
          try {
            this.showError("");
            this.updateCameraStatus("Requesting camera access...");

            const constraints = {
              video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: "user",
              },
            };

            this.stream = await navigator.mediaDevices.getUserMedia(
              constraints
            );
            this.video.srcObject = this.stream;

            this.video.onloadedmetadata = () => {
              this.resizeCanvas();
              this.isRunning = true;
              this.updateCameraStatus("Active");
              this.updateButtons();
              this.startHandDetection();
              console.log("Camera started successfully");
            };
          } catch (error) {
            console.error("Error accessing camera:", error);
            this.showError(`Camera access failed: ${error.message}`);
            this.updateCameraStatus("Error");
          }
        }

        async startHandDetection() {
          if (this.useFallback) {
            // Use fallback detection without MediaPipe
            this.startFallbackDetection();
            return;
          }

          if (!this.hands) {
            console.warn(
              "MediaPipe hands not initialized, switching to fallback"
            );
            this.startFallbackDetection();
            return;
          }

          try {
            // Try to use MediaPipe with manual frame processing instead of Camera class
            this.startManualFrameProcessing();
          } catch (error) {
            console.error("Error starting MediaPipe processing:", error);
            this.startFallbackDetection();
          }
        }

        startManualFrameProcessing() {
          // Process frames manually without the Camera class
          const processFrame = async () => {
            if (!this.isRunning || !this.hands) return;

            try {
              // Send video frame to MediaPipe
              await this.hands.send({ image: this.video });

              // Continue processing at ~30 FPS
              setTimeout(processFrame, 33);
            } catch (error) {
              console.error("Error processing frame:", error);
              this.startFallbackDetection();
            }
          };

          // Start processing
          processFrame();
        }

        startFallbackDetection() {
          console.log("Starting fallback hand detection...");

          this.useFallback = true;
          this.updateModelStatus("Fallback Mode");

          // Use simple canvas-based detection
          this.processFrameFallback();

          // Setup keyboard shortcuts for testing
          this.setupKeyboardShortcuts();
          this.updateFallbackUI();
        }

        processFrameFallback() {
          if (!this.isRunning) return;

          const startTime = performance.now();

          // Simple motion detection or color detection could go here
          // For now, we'll create a basic interaction system
          this.detectHandsFallback();

          // Update performance metrics
          const processingTime = performance.now() - startTime;
          this.updatePerformanceMetrics(processingTime);

          // Continue processing
          setTimeout(() => this.processFrameFallback(), 100); // 10 FPS
        }

        detectHandsFallback() {
          // Draw fallback UI
          this.drawFallbackOverlay();

          // Update UI elements
          this.updateDetectionUI();
        }

        drawFallbackOverlay() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // Draw instruction overlay
          this.ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
          this.ctx.fillRect(0, 0, this.canvas.width, 80);

          this.ctx.fillStyle = "#ffffff";
          this.ctx.font = "bold 18px Arial";
          this.ctx.textAlign = "center";
          this.ctx.fillText("Fallback Mode Active", this.canvas.width / 2, 25);

          this.ctx.font = "14px Arial";
          this.ctx.fillText(
            "Use keyboard shortcuts to simulate gestures:",
            this.canvas.width / 2,
            45
          );
          this.ctx.fillText(
            "1=üëç 2=‚úåÔ∏è 3=‚úä 4=ü§ö 5=üëâ 6=üëå 7=üëé 8=ü§ü",
            this.canvas.width / 2,
            65
          );

          this.ctx.textAlign = "left";

          // Show current gesture if any
          if (this.currentGesture) {
            const pattern = this.gesturePatterns[this.currentGesture];
            this.ctx.fillStyle = "rgba(0, 255, 0, 0.8)";
            this.ctx.fillRect(10, this.canvas.height - 50, 200, 40);

            this.ctx.fillStyle = "#000000";
            this.ctx.font = "bold 16px Arial";
            this.ctx.fillText(`${pattern.name}, 20, this.canvas.height - 25`);
            this.ctx.font = "12px Arial";
            this.ctx.fillText(
              `Confidence: ${(this.gestureConfidence * 100).toFixed(
                1
              )}%, 20, this.canvas.height - 10`
            );
          }
        }

        setupKeyboardShortcuts() {
          if (this.keyboardSetup) return;

          this.keyboardSetup = true;

          document.addEventListener("keydown", (event) => {
            if (!this.isRunning) return;

            let gesture = null;

            switch (event.key) {
              case "1":
                gesture = "thumbs_up";
                break;
              case "2":
                gesture = "peace";
                break;
              case "3":
                gesture = "fist";
                break;
              case "4":
                gesture = "open_palm";
                break;
              case "5":
                gesture = "pointing";
                break;
              case "6":
                gesture = "ok_sign";
                break;
              case "7":
                gesture = "thumbs_down";
                break;
              case "8":
                gesture = "i_love_you";
                break;
            }

            if (gesture) {
              this.simulateGestureDetection(gesture);
            }
          });
        }

        simulateGestureDetection(gesture) {
          this.currentGesture = gesture;
          this.gestureConfidence = 0.9;
          this.handsDetected = 1;

          // Add stability check
          if (this.currentGesture !== this.lastDetectedGesture) {
            this.gestureStabilityCounter = 0;
            this.lastDetectedGesture = this.currentGesture;
          }

          this.gestureStabilityCounter++;

          if (this.gestureStabilityCounter >= 3) {
            this.addGestureToText(gesture);
            this.gestureStabilityCounter = 0;
          }

          this.updateDetectionUI();
        }

        updateFallbackUI() {
          const instructions =
            "Fallback Mode: Use keyboard shortcuts (1-6) to simulate gestures. MediaPipe not available.";

          if (document.getElementById("fallbackInstructions")) {
            return;
          }

          const instructionEl = document.createElement("div");
          instructionEl.id = "fallbackInstructions";
          instructionEl.style.cssText = `
                  background: #ff9800;
                  color: white;
                  padding: 10px;
                  margin: 10px 0;
                  border-radius: 5px;
                  font-weight: bold;
                  text-align: center;`;
          instructionEl.textContent = instructions;

          const container =
            document.querySelector(".main-content") || document.body;
          container.insertBefore(instructionEl, container.firstChild);
        }

        onResults(results) {
          if (!this.isRunning) return;

          const startTime = performance.now();
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          this.handsDetected = results.multiHandLandmarks?.length || 0;

          if (this.handsDetected > 0) {
            this.handLandmarks = results.multiHandLandmarks;

            for (let i = 0; i < this.handLandmarks.length; i++) {
              const landmarks = this.handLandmarks[i];

              this.recognizeGestureForHand(i, landmarks); // ‚¨ÖÔ∏è New per-hand detection
              this.drawHandLandmarks(landmarks, i); // ‚¨ÖÔ∏è Draw each hand
            }
          } else {
            this.handLandmarks = null;
            this.currentGesture = null;
            this.gestureConfidence = 0;
            this.gestureStabilityCounter = 0;
          }

          this.updateDetectionUI();

          const processingTime = performance.now() - startTime;
          this.updatePerformanceMetrics(processingTime);
        }

        recognizeGestureForHand(handIndex, landmarks) {
          let detectedGesture = null;
          let maxConfidence = 0;

          for (const [gestureKey, pattern] of Object.entries(
            this.gesturePatterns
          )) {
            const confidence = pattern.check(landmarks);
            if (confidence > maxConfidence && confidence > 0.7) {
              maxConfidence = confidence;
              detectedGesture = gestureKey;
            }
          }

          if (!this.handGestureData) this.handGestureData = {};
          const prevGesture =
            this.handGestureData[handIndex]?.lastGesture || null;
          const stability = this.handGestureData[handIndex]?.stability || 0;

          if (detectedGesture === prevGesture) {
            this.handGestureData[handIndex].stability++;
          } else {
            this.handGestureData[handIndex] = {
              lastGesture: detectedGesture,
              stability: 1,
            };
          }

          const stable =
            this.handGestureData[handIndex].stability >=
            this.minStabilityFrames;

          if (
            stable &&
            detectedGesture &&
            this.handGestureData[handIndex].lastAdded !== detectedGesture
          ) {
            this.addGestureToText(detectedGesture);
            this.handGestureData[handIndex].lastAdded = detectedGesture;

            setTimeout(() => {
              this.handGestureData[handIndex].lastAdded = null;
            }, 2000);
          }
        }

        stopCamera() {
          this.isRunning = false;

          if (this.camera) {
            this.camera.stop();
            this.camera = null;
          }

          if (this.stream) {
            this.stream.getTracks().forEach((track) => track.stop());
            this.stream = null;
          }

          this.video.srcObject = null;
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          this.updateCameraStatus("Inactive");
          this.updateButtons();
          this.resetDetection();

          // Remove fallback instructions
          const instructionEl = document.getElementById("fallbackInstructions");
          if (instructionEl) {
            instructionEl.remove();
          }

          console.log("Camera stopped");
        }

        resizeCanvas() {
          const rect = this.video.getBoundingClientRect();
          this.canvas.width = rect.width;
          this.canvas.height = rect.height;
          this.canvas.style.width = rect.width + "px";
          this.canvas.style.height = rect.height + "px";
        }

        recognizeGesture() {
          if (!this.handLandmarks) return;

          let detectedGesture = null;
          let maxConfidence = 0;

          // Check each gesture pattern
          for (const [gestureKey, pattern] of Object.entries(
            this.gesturePatterns
          )) {
            const confidence = pattern.check(this.handLandmarks);
            if (confidence > maxConfidence && confidence > 0.7) {
              maxConfidence = confidence;
              detectedGesture = gestureKey;
            }
          }

          // Update gesture with stability check
          if (detectedGesture === this.currentGesture) {
            this.gestureStabilityCounter++;
            this.gestureConfidence = maxConfidence;
          } else {
            this.gestureStabilityCounter = 0;
            this.currentGesture = detectedGesture;
            this.gestureConfidence = detectedGesture ? maxConfidence : 0;
          }

          // Add to translated text if gesture is stable and confident
          if (
            this.gestureStabilityCounter >= this.minStabilityFrames &&
            this.gestureConfidence > 0.8 &&
            this.currentGesture !== this.lastAddedGesture
          ) {
            this.addGestureToText(this.currentGesture);
            this.lastAddedGesture = this.currentGesture;

            // Reset after some time
            setTimeout(() => {
              this.lastAddedGesture = null;
            }, 2000);
          }
        }

        // Helper function to check if finger is extended
        isFingerExtended(landmarks, fingerTip, fingerPip, wrist) {
          const tipY = landmarks[fingerTip].y;
          const pipY = landmarks[fingerPip].y;
          const wristY = landmarks[wrist].y;

          // Finger is extended if tip is above PIP joint and significantly above wrist
          return tipY < pipY && tipY < wristY - 0.05;
        }

        // Helper function to check if finger is folded
        isFingerFolded(landmarks, fingerTip, fingerPip, wrist) {
          const tipY = landmarks[fingerTip].y;
          const pipY = landmarks[fingerPip].y;
          const wristY = landmarks[wrist].y;

          // Finger is folded if tip is below PIP joint or close to wrist level
          return tipY > pipY || tipY > wristY - 0.02;
        }

        // Enhanced gesture recognition functions
        isThumbsUp(landmarks) {
          const thumbTip = landmarks[4];
          const thumbIP = landmarks[3];
          const thumbMCP = landmarks[2];
          const indexTip = landmarks[8];
          const middleTip = landmarks[12];
          const ringTip = landmarks[16];
          const pinkyTip = landmarks[20];
          const wrist = landmarks[0];

          // Thumb should be pointing up (tip above IP joint)
          const thumbUp = thumbTip.y < thumbIP.y && thumbTip.y < thumbMCP.y;

          // Other fingers should be folded
          const indexFolded = this.isFingerFolded(landmarks, 8, 6, 0);
          const middleFolded = this.isFingerFolded(landmarks, 12, 10, 0);
          const ringFolded = this.isFingerFolded(landmarks, 16, 14, 0);
          const pinkyFolded = this.isFingerFolded(landmarks, 20, 18, 0);

          const otherFingersFolded =
            indexFolded && middleFolded && ringFolded && pinkyFolded;

          // Calculate confidence based on how well it matches
          let confidence = 0;
          if (thumbUp) confidence += 0.6;
          if (otherFingersFolded) confidence += 0.4;

          return confidence;
        }
        isThumbsDown(landmarks) {
          const thumbTip = landmarks[4];
          const thumbIP = landmarks[3];
          const thumbMCP = landmarks[2];
          const wrist = landmarks[0];

          const indexFolded = this.isFingerFolded(landmarks, 8, 6, 0);
          const middleFolded = this.isFingerFolded(landmarks, 12, 10, 0);
          const ringFolded = this.isFingerFolded(landmarks, 16, 14, 0);
          const pinkyFolded = this.isFingerFolded(landmarks, 20, 18, 0);

          const thumbDown =
            thumbTip.y > thumbIP.y &&
            thumbTip.y > thumbMCP.y &&
            thumbTip.y > wrist.y;

          let confidence = 0;
          if (thumbDown) confidence += 0.6;
          if (indexFolded && middleFolded && ringFolded && pinkyFolded)
            confidence += 0.4;

          return confidence;
        }

        isPeaceSign(landmarks) {
          const wrist = landmarks[0];

          // Check if index and middle fingers are extended
          const indexExtended = this.isFingerExtended(landmarks, 8, 6, 0);
          const middleExtended = this.isFingerExtended(landmarks, 12, 10, 0);

          // Check if ring and pinky are folded
          const ringFolded = this.isFingerFolded(landmarks, 16, 14, 0);
          const pinkyFolded = this.isFingerFolded(landmarks, 20, 18, 0);

          // Check thumb position (should be folded or neutral)
          const thumbFolded = landmarks[4].y > landmarks[3].y;

          // Additional check: index and middle should be separated
          const indexTip = landmarks[8];
          const middleTip = landmarks[12];
          const fingerSeparation = Math.abs(indexTip.x - middleTip.x) > 0.03;

          let confidence = 0;
          if (indexExtended && middleExtended) confidence += 0.5;
          if (ringFolded && pinkyFolded) confidence += 0.3;
          if (thumbFolded) confidence += 0.1;
          if (fingerSeparation) confidence += 0.1;

          return confidence;
        }

        isFist(landmarks) {
          const wrist = landmarks[0];

          // All fingers should be folded
          const thumbFolded = landmarks[4].y > landmarks[2].y;
          const indexFolded = this.isFingerFolded(landmarks, 8, 6, 0);
          const middleFolded = this.isFingerFolded(landmarks, 12, 10, 0);
          const ringFolded = this.isFingerFolded(landmarks, 16, 14, 0);
          const pinkyFolded = this.isFingerFolded(landmarks, 20, 18, 0);

          const allFingersFolded =
            thumbFolded &&
            indexFolded &&
            middleFolded &&
            ringFolded &&
            pinkyFolded;

          // Check compactness - fingertips should be close to palm
          const palmCenter = landmarks[9]; // Middle finger MCP
          let avgDistanceToPalm = 0;
          const fingertips = [4, 8, 12, 16, 20];

          fingertips.forEach((tip) => {
            const distance = Math.sqrt(
              Math.pow(landmarks[tip].x - palmCenter.x, 2) +
                Math.pow(landmarks[tip].y - palmCenter.y, 2)
            );
            avgDistanceToPalm += distance;
          });
          avgDistanceToPalm /= fingertips.length;

          const compact = avgDistanceToPalm < 0.1;

          let confidence = 0;
          if (allFingersFolded) confidence += 0.7;
          if (compact) confidence += 0.3;

          return confidence;
        }

        isOpenPalm(landmarks) {
          const wrist = landmarks[0];

          // All fingers should be extended
          const thumbExtended = landmarks[4].y < landmarks[2].y;
          const indexExtended = this.isFingerExtended(landmarks, 8, 6, 0);
          const middleExtended = this.isFingerExtended(landmarks, 12, 10, 0);
          const ringExtended = this.isFingerExtended(landmarks, 16, 14, 0);
          const pinkyExtended = this.isFingerExtended(landmarks, 20, 18, 0);

          const allFingersExtended =
            thumbExtended &&
            indexExtended &&
            middleExtended &&
            ringExtended &&
            pinkyExtended;

          // Check if fingers are spread (not too close together)
          const spreadEnough =
            Math.abs(landmarks[8].x - landmarks[4].x) > 0.15 && // Index and thumb
            Math.abs(landmarks[20].x - landmarks[4].x) > 0.2; // Pinky and thumb

          const fingersSpread = spreadEnough;

          let confidence = 0;
          if (allFingersExtended) confidence += 0.8;
          if (fingersSpread) confidence += 0.2;

          return confidence;
        }

        isPointing(landmarks) {
          const wrist = landmarks[0];

          // Only index finger should be extended
          const indexExtended = this.isFingerExtended(landmarks, 8, 6, 0);
          const middleFolded = this.isFingerFolded(landmarks, 12, 10, 0);
          const ringFolded = this.isFingerFolded(landmarks, 16, 14, 0);
          const pinkyFolded = this.isFingerFolded(landmarks, 20, 18, 0);

          // Thumb can be either folded or extended
          const thumbNeutral = true; // More permissive with thumb

          // Check if index finger is pointing forward (relatively straight)
          const indexTip = landmarks[8];
          const indexPip = landmarks[6];
          const indexMcp = landmarks[5];

          // Index should be relatively straight
          const indexStraight =
            Math.abs(indexTip.y - indexPip.y - (indexPip.y - indexMcp.y)) <
            0.02;

          let confidence = 0;
          if (indexExtended) confidence += 0.4;
          if (middleFolded && ringFolded && pinkyFolded) confidence += 0.4;
          if (indexStraight) confidence += 0.2;

          return confidence;
        }

        isOKSign(landmarks) {
          const thumbTip = landmarks[4];
          const indexTip = landmarks[8];
          const middleTip = landmarks[12];
          const ringTip = landmarks[16];
          const pinkyTip = landmarks[20];
          const wrist = landmarks[0];

          // Calculate distance between thumb and index finger tips
          const thumbIndexDistance = Math.sqrt(
            Math.pow(thumbTip.x - indexTip.x, 2) +
              Math.pow(thumbTip.y - indexTip.y, 2)
          );

          // Thumb and index should be close (forming circle)
          const circleFormed = thumbIndexDistance < 0.04;

          // Other fingers should be extended
          const middleExtended = this.isFingerExtended(landmarks, 12, 10, 0);
          const ringExtended = this.isFingerExtended(landmarks, 16, 14, 0);
          const pinkyExtended = this.isFingerExtended(landmarks, 20, 18, 0);

          const otherFingersUp =
            middleExtended && ringExtended && pinkyExtended;

          // Additional check: circle should be roughly round
          const thumbIndexMidpoint = {
            x: (thumbTip.x + indexTip.x) / 2,
            y: (thumbTip.y + indexTip.y) / 2,
          };

          let confidence = 0;
          if (circleFormed) confidence += 0.6;
          if (otherFingersUp) confidence += 0.4;

          return confidence;
        }
        isILoveYou(landmarks) {
          const thumbExtended = this.isFingerExtended(landmarks, 4, 3, 0);
          const indexExtended = this.isFingerExtended(landmarks, 8, 6, 0);
          const pinkyExtended = this.isFingerExtended(landmarks, 20, 18, 0);

          const middleFolded = this.isFingerFolded(landmarks, 12, 10, 0);
          const ringFolded = this.isFingerFolded(landmarks, 16, 14, 0);

          let confidence = 0;
          if (thumbExtended && indexExtended && pinkyExtended)
            confidence += 0.6;
          if (middleFolded && ringFolded) confidence += 0.4;

          return confidence;
        }
        isNumberThree(landmarks) {
          const index = this.isFingerExtended(landmarks, 8, 6, 0);
          const middle = this.isFingerExtended(landmarks, 12, 10, 0);
          const ring = this.isFingerExtended(landmarks, 16, 14, 0);
          const pinky = this.isFingerFolded(landmarks, 20, 18, 0);
          const thumb = this.isFingerFolded(landmarks, 4, 3, 0);

          let confidence = 0;
          if (index && middle && ring) confidence += 0.6;
          if (pinky && thumb) confidence += 0.4;

          return confidence;
        }

        isRockSign(landmarks) {
          const thumbExtended = this.isFingerExtended(landmarks, 4, 3, 0);
          const indexExtended = this.isFingerExtended(landmarks, 8, 6, 0);
          const pinkyExtended = this.isFingerExtended(landmarks, 20, 18, 0);

          const middleFolded = this.isFingerFolded(landmarks, 12, 10, 0);
          const ringFolded = this.isFingerFolded(landmarks, 16, 14, 0);

          // Extra checks to reduce false positives
          const indexAboveMiddle = landmarks[8].y < landmarks[12].y;
          const pinkyAboveRing = landmarks[20].y < landmarks[16].y;
          const thumbNotNearIndex =
            Math.abs(landmarks[4].x - landmarks[8].x) > 0.1;

          let confidence = 0;
          if (thumbExtended && indexExtended && pinkyExtended)
            confidence += 0.5;
          if (middleFolded && ringFolded) confidence += 0.3;
          if (indexAboveMiddle && pinkyAboveRing && thumbNotNearIndex)
            confidence += 0.2;

          return confidence;
        }

        addGestureToText(gesture) {
          const pattern = this.gesturePatterns[gesture];
          if (pattern) {
            this.translatedText += pattern.text;
            this.updateTranslatedText();
          }
        }

        
        drawHandLandmarks(landmarks, handIndex) {
          this.ctx.fillStyle = "#00ff00";
          this.ctx.strokeStyle = "#00aa00";
          this.ctx.lineWidth = 2;

          // Draw landmarks
          landmarks.forEach((landmark, index) => {
            const x = landmark.x * this.canvas.width;
            const y = landmark.y * this.canvas.height;

            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, 2 * Math.PI);
            this.ctx.fill();

            this.ctx.fillStyle = "#ffffff";
            this.ctx.font = "10px Arial";
            this.ctx.fillText(index, x + 6, y - 6);
            this.ctx.fillStyle = "#00ff00";
          });

          // Draw connections
          this.drawHandConnections(landmarks);

          // ‚úÖ Draw hand label (e.g., "Hand 1", "Hand 2")
          const wrist = landmarks[0];
          const x = wrist.x * this.canvas.width;
          const y = wrist.y * this.canvas.height - 20;

          this.ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
          this.ctx.fillRect(x - 10, y - 15, 60, 20);
          this.ctx.fillStyle = "#ffffff";
          this.ctx.font = "12px Arial";
          this.ctx.fillText(`Hand ${handIndex + 1}`, x, y);
        }

        drawHandConnections(landmarks) {
          // MediaPipe hand connections
          const connections = [
            [0, 1],
            [1, 2],
            [2, 3],
            [3, 4], // thumb
            [0, 5],
            [5, 6],
            [6, 7],
            [7, 8], // index
            [0, 9],
            [9, 10],
            [10, 11],
            [11, 12], // middle
            [0, 13],
            [13, 14],
            [14, 15],
            [15, 16], // ring
            [0, 17],
            [17, 18],
            [18, 19],
            [19, 20], // pinky
            [5, 9],
            [9, 13],
            [13, 17], // palm
          ];

          this.ctx.strokeStyle = "#00aa00";
          this.ctx.lineWidth = 2;

          connections.forEach(([start, end]) => {
            if (landmarks[start] && landmarks[end]) {
              const startX = landmarks[start].x * this.canvas.width;
              const startY = landmarks[start].y * this.canvas.height;
              const endX = landmarks[end].x * this.canvas.width;
              const endY = landmarks[end].y * this.canvas.height;

              this.ctx.beginPath();
              this.ctx.moveTo(startX, startY);
              this.ctx.lineTo(endX, endY);
              this.ctx.stroke();
            }
          });
        }

        drawGestureLabel() {
          const pattern = this.gesturePatterns[this.currentGesture];
          if (!pattern) return;

          const text = `${pattern.name} (${(
            this.gestureConfidence * 100
          ).toFixed(1)}%)`;
          const x = 10;
          const y = 30;

          // Draw background
          this.ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          this.ctx.fillRect(x - 5, y - 20, text.length * 8, 25);

          // Draw text
          this.ctx.fillStyle = "#ffffff";
          this.ctx.font = "16px Arial";
          this.ctx.fillText(text, x, y);
        }

        updatePerformanceMetrics(processingTime) {
          this.processingTimes.push(processingTime);
          if (this.processingTimes.length > 60) {
            this.processingTimes.shift();
          }

          this.frameCount++;
          const currentTime = performance.now();
          const deltaTime = currentTime - this.lastFrameTime;

          if (deltaTime >= 1000) {
            const fps = Math.round((this.frameCount * 1000) / deltaTime);
            const avgProcessingTime =
              this.processingTimes.reduce((a, b) => a + b, 0) /
              this.processingTimes.length;

            document.getElementById("frameRate").textContent = `${fps} FPS`;
            document.getElementById(
              "processingTime"
            ).textContent = `${avgProcessingTime.toFixed(1)}ms`;

            this.frameCount = 0;
            this.lastFrameTime = currentTime;
          }
        }

        updateDetectionUI() {
          document.getElementById("handsDetected").textContent =
            this.handsDetected;
          document.getElementById("confidence").textContent = ` ${(
            this.gestureConfidence * 100
          ).toFixed(1)}%`;

          if (this.currentGesture && this.gestureConfidence > 0.7) {
            const pattern = this.gesturePatterns[this.currentGesture];
            document.getElementById("gestureOutput").textContent = pattern.name;
            this.highlightGesture(this.currentGesture);
          } else {
            document.getElementById("gestureOutput").textContent =
              "No gesture detected";
            this.clearGestureHighlight();
          }
        }

        highlightGesture(gestureKey) {
          document.querySelectorAll(".gesture-item").forEach((item) => {
            item.classList.remove("detected");
          });

          const gestureElement = document.querySelector(
            `[data-gesture="${gestureKey}"]`
          );
          if (gestureElement) {
            gestureElement.classList.add("detected");
          }
        }

        clearGestureHighlight() {
          document.querySelectorAll(".gesture-item").forEach((item) => {
            item.classList.remove("detected");
          });
        }

        updateTranslatedText() {
          document.getElementById("translatedText").textContent =
            this.translatedText || "Your translated text will appear here...";
        }

        clearText() {
          this.translatedText = "";
          this.updateTranslatedText();
          console.log("Translated text cleared");
        }

        trainGesture() {
          if (!this.currentGesture) {
            alert("Please show a gesture first to train the model");
            return;
          }

          const gestureName = prompt("Enter a name for this gesture:");
          if (gestureName) {
            const text = prompt("Enter the text this gesture should produce:");
            if (text) {
              // In a real implementation, this would save to a model
              console.log(`Training gesture: ${gestureName} -> ${text}`);
              alert(`Gesture "${gestureName}" trained successfully!`);
            }
          }
        }

        updateCameraStatus(status) {
          const statusEl = document.getElementById("cameraStatus");
          statusEl.innerHTML = ` <span class="status-indicator ${
            status === "Active" ? "status-active" : "status-inactive"
          }"></span>${status}`;
        }

        updateModelStatus(status) {
          document.getElementById("modelStatus").textContent = status;
        }

        updateButtons() {
          document.getElementById("startBtn").disabled = this.isRunning;
          document.getElementById("stopBtn").disabled = !this.isRunning;
        }

        resetDetection() {
          this.handsDetected = 0;
          this.currentGesture = null;
          this.gestureConfidence = 0;
          this.handLandmarks = null;
          this.gestureHistory = [];
          this.gestureStabilityCounter = 0;
          this.updateDetectionUI();
        }

        showError(message) {
          const errorEl = document.getElementById("errorMessage");
          if (message) {
            errorEl.textContent = message;
            errorEl.style.display = "block";
          } else {
            errorEl.style.display = "none";
          }
        }

        updateUI() {
          this.updateButtons();
          this.updateTranslatedText();
          this.updateDetectionUI();
        }
      }

      // Initialize the application
      document.addEventListener("DOMContentLoaded", () => {
        const recognizer = new HandGestureRecognizer();

        // Add helpful console messages
        console.log("ü§ö Hand Gesture Recognition System Initialized");
        console.log("üìã Available features:");
        console.log("  ‚Ä¢ MediaPipe hand detection (with fallback)");
        console.log("  ‚Ä¢ Gesture recognition");
        console.log("  ‚Ä¢ Text translation");
        console.log("  ‚Ä¢ Performance monitoring");
        console.log('üöÄ Click "Start Camera" to begin!');
      });

      // Add error handling for uncaught errors
      window.addEventListener("error", (event) => {
        console.error("Application error:", event.error);
        const errorEl = document.getElementById("errorMessage");
        if (errorEl) {
          errorEl.textContent = "Application error: ${event.error.message}";
          errorEl.style.display = "block";
        }
      });

      // Add performance monitoring
      if ("performance" in window) {
        window.addEventListener("load", () => {
          const loadTime = performance.now();
          console.log("üìà Application loaded in ${loadTime.toFixed(2)}ms");
        });
      }
    </script>
  </body>
</html>
